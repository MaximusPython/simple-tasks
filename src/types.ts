import 'reflect-metadata';

export const TYPES = {
	App: Symbol.for('App'),
	Ilogger: Symbol.for('Ilogger'),
	UserController: Symbol.for('UserController'),
	UserService: Symbol.for('UserService'),
	ExeptionFilter: Symbol.for('ExeptionFilter'),
	ConfigServie: Symbol.for('ConfigServie'),
	PrismaService: Symbol.for('PrismaService'),
	UserRepository: Symbol.for('UserRepository'),
};
// эти записи потребуется для токенов
// определяем символы по которым мы будем связывать

//
// Шаг 1: Установка InversifyJS
// В терминале выполнить команду: npm install inversify
// Библиотека добавится в файл package.json

// Шаг 2: Символы для связывания
// Создать файл FileTypes.ts для хранения символов
// Символы уникальны и используются для связывания компонентов
// Пример символов: Application, LoggerService, UserController, ExceptionFilter

// Шаг 3: Создание контейнера
// Использовать main.ts для агрегации Dependency Injection
// Создать контейнер AppContainer с помощью Inversify.js
// Контейнер - это место для хранения и переиспользования биндингов

// Шаг 4: Биндинг компонентов
// Для каждого компонента (например, ILogger) выполнить биндинг с его реализацией (например, LoggerService)
// Использовать соответствующий символ для связывания

// Шаг 5: Использование декораторов
// Использовать декоратор @injectable для указания классов, которые можно помещать в контейнер
// Использовать декоратор @inject для внедрения зависимостей по определенному символу

// Шаг 6: Получение экземпляров из контейнера
// Использовать метод get контейнера для получения экземпляров по символам
// Позволяет получить приложение и другие компоненты для инициализации

// Шаг 7: Экспорт и инициализация
// Инициировать приложение с помощью app.init()
// Экспортировать app и app.container для дальнейшего использования, например, в тестах
// Преимущества использования InversifyJS
// Возможность легко получать и переиспользовать экземпляры через контейнер
// Упрощение управления зависимостями и их инжектирования
// В тестах можно заменять реализации, делая код более гибким и тестируемым
// Важно:
// Для корректной работы декораторов и зависимостей необходимо использовать Reflect-metadata
// Проверка и обновления импортов Reflect-metadata там, где используются декораторы
